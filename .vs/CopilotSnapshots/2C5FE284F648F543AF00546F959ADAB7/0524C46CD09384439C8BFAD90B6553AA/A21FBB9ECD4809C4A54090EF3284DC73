#include <vector>
#include <ctime>
#include "TextureBuilder.h"
#include "Model_3DS.h"
#include "GLTexture.h"
#include <glut.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <mmsystem.h>
#include <string>

// Link the Windows Multimedia library for sound
#pragma comment(lib, "winmm.lib")

#define WIDTH 1280
#define HEIGHT 720
#define PI 3.1415926535f

// ===== GAME STATE ENUMERATION =====
enum GameState { MENU, LEVEL_1, WIN, LOSE, LEVEL_2 };
GameState gameState = MENU; // Start in Menu

// ---------------- SOUND CONFIGURATION ----------------
static const wchar_t* ALIAS_BGM = L"bgm";
static const wchar_t* ALIAS_COIN_PICKUP = L"s_coin";
static const wchar_t* ALIAS_MAP_PICKUP = L"s_ma_pickup";
static const wchar_t* ALIAS_COLLISION = L"s_collision";
static const wchar_t* ALIAS_GAMEOVER = L"s_gameover";
static const wchar_t* ALIAS_NPC_INTERACT = L"s_npc_interact";
static const wchar_t* ALIAS_BOAT_INTERACT = L"s_boat_interact";
static const wchar_t* ALIAS_JUMP = L"s_jump";

// SOUND PATHS (Update these if needed)
static const wchar_t* PATH_BGM = L"D:\\Sem 5\\Computer Graphics\\Project\\Project\\SFX\\.mp3";
static const wchar_t* PATH_COIN_PICKUP = L"D:\\Sem 5\\Computer Graphics\\Project\\Project\\SFX\\Coin-Gem Found.mp3";
static const wchar_t* PATH_MAP_PICKUP = L"D:\\Sem 5\\Computer Graphics\\Project\\Project\\SFX\\Map Found.mp3";
static const wchar_t* PATH_NPC_INTERACT = L"D:\\Sem 5\\Computer Graphics\\Project\\Project\\SFX\\Interact With Npc.mp3";
static const wchar_t* PATH_BOAT_INTERACT = L"D:\\Sem 5\\Computer Graphics\\Project\\Project\\SFX\\Boat-Interact.mp3";
static const wchar_t* PATH_JUMP = L"D:\\Sem 5\\Computer Graphics\\Project\\Project1\\SFX\\Jump.mp3";
static const wchar_t* PATH_COLLISION = L"C:\\Users\\moham\\Downloads\\hit-soundvideo-game-type-230510.mp3";
static const wchar_t* PATH_GAMEOVER = L"C:\\Users\\moham\\Downloads\\game-over-38511.mp3";

static bool showBoatInsufficient = false;
static bool soundsInitialized = false;
static bool gameOverSoundPlayed = false;
static int lastCollisionTime = 0;
const int COLLISION_SOUND_COOLDOWN = 300;

// ---------------- SOUND HELPER FUNCTIONS ----------------
static void MciOpen(const wchar_t* alias, const wchar_t* path) {
    std::wstring cmd = L"open \""; cmd += path; cmd += L"\" type mpegvideo alias "; cmd += alias;
    mciSendStringW(cmd.c_str(), nullptr, 0, nullptr);
}
static void MciClose(const wchar_t* alias) {
    std::wstring cmd = L"close "; cmd += alias; mciSendStringW(cmd.c_str(), nullptr, 0, nullptr);
}
static void MciStop(const wchar_t* alias) {
    std::wstring cmd = L"stop "; cmd += alias; mciSendStringW(cmd.c_str(), nullptr, 0, nullptr);
}
static void MciPlayLoop(const wchar_t* alias) {
    std::wstring cmd = L"play "; cmd += alias; cmd += L" repeat"; mciSendStringW(cmd.c_str(), nullptr, 0, nullptr);
}
static void MciPlayOnce(const wchar_t* alias) {
    std::wstring stopCmd = L"stop "; stopCmd += alias;
    mciSendStringW(stopCmd.c_str(), nullptr, 0, nullptr);
    std::wstring seekCmd = L"seek "; seekCmd += alias; seekCmd += L" to start";
    mciSendStringW(seekCmd.c_str(), nullptr, 0, nullptr);
    std::wstring playCmd = L"play "; playCmd += alias;
    mciSendStringW(playCmd.c_str(), nullptr, 0, nullptr);
}
static void Sound_Init() {
    if (soundsInitialized) return;
    MciOpen(ALIAS_BGM, PATH_BGM); MciOpen(ALIAS_COIN_PICKUP, PATH_COIN_PICKUP);
    MciOpen(ALIAS_MAP_PICKUP, PATH_MAP_PICKUP); MciOpen(ALIAS_COLLISION, PATH_COLLISION);
    MciOpen(ALIAS_GAMEOVER, PATH_GAMEOVER); MciOpen(ALIAS_NPC_INTERACT, PATH_NPC_INTERACT);
    MciOpen(ALIAS_BOAT_INTERACT, PATH_BOAT_INTERACT); MciOpen(ALIAS_JUMP, PATH_JUMP);
    soundsInitialized = true;
}
static void Sound_Shutdown() {
    MciClose(ALIAS_GAMEOVER); MciClose(ALIAS_COLLISION); MciClose(ALIAS_BOAT_INTERACT);
    MciClose(ALIAS_NPC_INTERACT); MciClose(ALIAS_MAP_PICKUP); MciClose(ALIAS_COIN_PICKUP);
    MciClose(ALIAS_JUMP); MciClose(ALIAS_BGM);
}


// ---------------- GLOBAL VARIABLES ----------------
GLuint tex;
GLTexture skyboxTexture;
GLTexture groundTexture;
GLTexture tex_menu_bg;
GLTexture tex_play_btn;

// --- NEW TEXTURE FOR CHEST ---
GLTexture tex_chest;

char title[] = "Pirate's Run - Multi-Level";
static const float LAND_SIZE = 300.0f;
static const float WORLD_SIZE = LAND_SIZE + 100.0f;
static const float GROUND_Y = 0.0f;
static const float WATER_Y = -2.0f;

// ---------------- LEVEL 1 OBJECTS ----------------
struct MapInstance { float x, y, z; float scale; float spinDeg; bool placed; };
static MapInstance g_mapRoad = { 0.0f, 1.0f, 0.0f, 2.0f, 0.0f, false };
static bool hasMap = true;

struct NPCInstance { float x, y, z; float yawDeg; float scale; bool placed; };
static NPCInstance g_npc = { 5.0f, 0.0f, 5.0f, 180.0f, 0.02f, true };

static bool showInteractPrompt = false;
static bool showNPCDialogue = false;
static float dialogueTimer = 0.0f;
static const float DIALOGUE_DURATION = 5.0f;
static const float NPC_INTERACT_DISTANCE = 5.0f;

struct BoatInstance { float x, y, z; float yawDeg; float scale; bool placed; };
static BoatInstance g_boat = { 0.0f, GROUND_Y, 0.0f, 0.0f, 1.0f, false };

static bool showBoatPrompt = false;
static bool showBoatDialogue = false;
static bool showBoatDialogue2 = false;
static float boatDialogueTimer = 0.0f;

static const float BOAT_INTERACT_DISTANCE = 30.0f;

static bool paidForBoat = false;
static const int BOAT_COST = 10;

// Level 1 Environment Instances
struct TreeInstance { float x, y, z; float yawDeg; float scale; };
static std::vector<TreeInstance> g_trees;
struct HouseInstance { float x, y, z; float yawDeg; float scale; };
static std::vector<HouseInstance> g_houses;
struct RockInstance { float x, y, z; float yawDeg; float scale; int modelIndex; };
static std::vector<RockInstance> g_rocks;
struct CoinInstance { float x, y, z; float spinDeg; float scale; bool active; };
static std::vector<CoinInstance> g_coins;

// Level 1 Platforms
struct Platform { float x, y, z, size; };
static constexpr int PLATFORM_COUNT = 9;
static Platform g_platforms[PLATFORM_COUNT] = {
    { (WORLD_SIZE * 0.5f) - 8.0f, 2.0f, (WORLD_SIZE * 0.5f) - 6.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) + 6.0f, 4.0f, (WORLD_SIZE * 0.5f) - 3.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) - 5.0f, 6.4f, (WORLD_SIZE * 0.5f) + 4.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) + 8.0f, 8.8f, (WORLD_SIZE * 0.5f) + 2.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) - 10.0f, 10.2f, (WORLD_SIZE * 0.5f) - 1.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) + 10.0f, 12.6f, (WORLD_SIZE * 0.5f) - 7.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) - 7.0f, 14.0f, (WORLD_SIZE * 0.5f) + 8.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) + 2.0f, 16.4f, (WORLD_SIZE * 0.5f) + 10.0f, 2.5f },
    { (WORLD_SIZE * 0.5f) - 12.0f, 18.8f, (WORLD_SIZE * 0.5f) + 12.0f, 2.5f },
};

// ---------------- LEVEL 2 OBJECTS ----------------
struct Lvl2Platform { float x, z, width, length, y; };
static std::vector<Lvl2Platform> lvl2_platforms;

struct Pendulum {
    float pivotX, pivotY, pivotZ;
    float length;
    float currentAngle;
    float maxAngle;
    float speed;
    bool axisZ; // true = side-to-side, false = front-to-back
};
static std::vector<Pendulum> lvl2_pendulums;

// Level 1 & 2 Game Objects
struct GameObject { float x, y, z; bool active; float r, g, b; };
GameObject keyObj = { 20.0f, 0.5f, 20.0f, true, 1.0f, 1.0f, 0.0f }; // Level 1 Key
GameObject lvl2_key = { 40.0f, 2.0f, 80.0f, true, 1, 1, 0 }; // Level 2 Key

struct Chest { float x, y, z; bool isOpen; };
Chest lvl2_chest = { 0.0f, 2.0f, 130.0f, false }; // Level 2 Chest

bool hasKey = false;
bool hasLvl2Key = false;
int score = 0;
int coinsCollected = 10;
float gameTimer = 0.0f;

// ---------------- TRANSITION STATE ----------------
static float fadeAlpha = 0.0f;
static bool isFadingOut = false;
static bool isFadingIn = false;

// ---------------- CAMERA & PLAYER STATE ----------------
float playerX = 2.0f;
float playerZ = 2.0f;
float playerY = 0.0f;
float playerYaw = 0.0f;

float camYaw = 0.0f;
float camPitch = 15.0f;
float camDistance = 15.0f;
bool isFirstPerson = false;
bool rotatingCamera = false;
int lastMouseX = -1;
int lastMouseY = -1;

float velX = 0.0f, velZ = 0.0f;
float velY = 0.0f;
const float accel = 18.0f;
const float maxSpeed = 24.0f;
const float frictionGround = 105.0f;
const float frictionAir = 75.0f;
const float gravity = 15.0f;
const float jumpImpulse = 7.0f;
const float maxFallSpeed = -15.0f;

bool keyW = false, keyA = false, keyS = false, keyD = false;
bool spaceTrigger = false;
bool grounded = true;
int jumpCount = 0;

// ---------------- MODELS ----------------
Model_3DS model_pirate;
Model_3DS model_key;
Model_3DS model_rocks[5];
Model_3DS model_houses;
Model_3DS model_tree;
Model_3DS model_map;
Model_3DS model_boat;
Model_3DS model_palet;
Model_3DS model_spike;

// --- NEW MODEL FOR CHEST ---
Model_3DS model_chest_3d;


// ---------------- HELPER FUNCTIONS & COLLISION ----------------

static float frand(float minV, float maxV) { return minV + (maxV - minV) * (rand() / (float)RAND_MAX); }

static bool IsOnLevel2Platform(float x, float z) {
    for (const auto& p : lvl2_platforms) {
        float halfW = p.width / 2.0f;
        float halfL = p.length / 2.0f;
        if (x >= (p.x - halfW) && x <= (p.x + halfW) && z >= (p.z - halfL) && z <= (p.z + halfL)) return true;
    }
    return false;
}

static inline bool IsOverLand(float x, float z) {
    if (gameState == LEVEL_2) return IsOnLevel2Platform(x, z);
    return x >= 0.0f && x <= LAND_SIZE && z >= 0.0f && z <= LAND_SIZE;
}

static inline bool CollidesWithTree(float x, float z, float radius) {
    if (gameState != LEVEL_1) return false;
    const float minDist2 = pow(radius + 1.5f, 2);
    for (const auto& t : g_trees) if ((pow(x - t.x, 2) + pow(z - t.z, 2)) < minDist2) return true;
    return false;
}
static inline bool CollidesWithRock(float x, float z, float radius) {
    if (gameState != LEVEL_1) return false;
    const float minDist2 = pow(radius + 2.0f, 2);
    for (const auto& r : g_rocks) if ((pow(x - r.x, 2) + pow(z - r.z, 2)) < minDist2) return true;
    return false;
}
static inline bool CollidesWithHouse(float x, float z, float radius) {
    if (gameState != LEVEL_1) return false;
    const float minDist2 = pow(radius + 3.5f, 2);
    for (const auto& h : g_houses) if ((pow(x - h.x, 2) + pow(z - h.z, 2)) < minDist2) return true;
    return false;
}
static inline bool CollidesWithBoat(float x, float z, float radius) {
    if (gameState != LEVEL_1 || !g_boat.placed) return false;
    return ((pow(x - g_boat.x, 2) + pow(z - g_boat.z, 2)) < pow(radius + 4.0f, 2));
}
static inline bool CollidesWithNPC(float x, float z, float radius) {
    if (gameState != LEVEL_1 || !g_npc.placed) return false;
    return ((pow(x - g_npc.x, 2) + pow(z - g_npc.z, 2)) < pow(radius + 1.0f, 2));
}

static inline bool CollidesWithAnyObject(float x, float z, float radius) {
    return CollidesWithTree(x, z, radius) || CollidesWithRock(x, z, radius) || CollidesWithHouse(x, z, radius);
}
static inline bool CollidesWithNPCSilent(float x, float z, float radius) {
    return CollidesWithNPC(x, z, radius);
}
static inline bool CollidesWithBoatSilent(float x, float z, float radius) {
    return CollidesWithBoat(x, z, radius);
}

// Helper: Level 2 Pendulum Collision
static bool CollidesWithPendulum(float x, float z, float y, float radius) {
    if (gameState != LEVEL_2) return false;
    for (const auto& p : lvl2_pendulums) {
        float rad = p.currentAngle * PI / 180.0f;
        float spikeX = p.pivotX;
        float spikeY = p.pivotY - p.length * cos(rad);
        float spikeZ = p.pivotZ;

        if (p.axisZ) spikeX += p.length * sin(rad);
        else spikeZ += p.length * sin(rad);

        float dist = sqrt(pow(x - spikeX, 2) + pow(y + 1.0f - spikeY, 2) + pow(z - spikeZ, 2));

        // Extended hitbox radius
        if (dist < (3.5f + radius)) return true;
    }
    return false;
}

// ---------------- LEVEL 1 PLACEMENT FUNCTIONS ----------------

static void PlaceBoatAtEdge() {
    g_boat.x = LAND_SIZE / 2.0f;
    g_boat.z = LAND_SIZE - 5.0f;
    g_boat.y = GROUND_Y + 0.5f;
    g_boat.yawDeg = 180.0f;
    g_boat.scale = 1.0f;
    g_boat.placed = true;
}

static inline bool InStreetZone(float x, float z) {
    const float centerX = WORLD_SIZE * 0.5f;
    const float centerZ = WORLD_SIZE * 0.5f;
    const float halfX = (16.0f * 0.5f) + 12.0f + 6.0f;
    const float halfZ = (6.0f * 2.0f) + 3.0f;
    return (x >= (centerX - halfX) && x <= (centerX + halfX) && z >= (centerZ - halfZ) && z <= (centerZ + halfZ));
}

static void PlacePirateMapInRoad() {
    const float centerX = (WORLD_SIZE * 0.5f) - 12.0f;
    const float centerZ = (WORLD_SIZE * 0.5f) + 12.0f;
    g_mapRoad.x = centerX; g_mapRoad.z = centerZ; g_mapRoad.y = 20.8f;
    g_mapRoad.scale = 0.1f; g_mapRoad.spinDeg = 0.0f; g_mapRoad.placed = true;
}

void PlaceTreesRandom(int count) {
    g_trees.clear();
    std::vector<TreeInstance> fixedTrees = {
        {20.0f, 0.0f, 20.0f, 45.0f, 0.40f}, {280.0f, 0.0f, 20.0f, 90.0f, 0.40f},
        {20.0f, 0.0f, 280.0f, 135.0f, 0.40f}, {280.0f, 0.0f, 280.0f, 180.0f, 0.40f},
        {35.0f, 0.0f, 45.0f, 225.0f, 0.40f}, {65.0f, 0.0f, 30.0f, 270.0f, 0.40f},
        {50.0f, 0.0f, 75.0f, 315.0f, 0.40f}, {235.0f, 0.0f, 45.0f, 0.0f, 0.40f},
        {265.0f, 0.0f, 30.0f, 45.0f, 0.40f}, {250.0f, 0.0f, 75.0f, 90.0f, 0.40f},
        {35.0f, 0.0f, 255.0f, 135.0f, 0.40f}, {65.0f, 0.0f, 270.0f, 180.0f, 0.40f},
        {50.0f, 0.0f, 225.0f, 225.0f, 0.40f}, {235.0f, 0.0f, 255.0f, 270.0f, 0.40f},
        {265.0f, 0.0f, 270.0f, 315.0f, 0.40f}, {250.0f, 0.0f, 225.0f, 0.0f, 0.40f},
        {30.0f, 0.0f, 100.0f, 45.0f, 0.40f}, {40.0f, 0.0f, 150.0f, 90.0f, 0.40f},
        {30.0f, 0.0f, 200.0f, 135.0f, 0.40f}, {270.0f, 0.0f, 100.0f, 180.0f, 0.40f},
        {260.0f, 0.0f, 150.0f, 225.0f, 0.40f}, {270.0f, 0.0f, 200.0f, 270.0f, 0.40f},
        {80.0f, 0.0f, 25.0f, 315.0f, 0.40f}, {120.0f, 0.0f, 35.0f, 0.0f, 0.40f},
        {160.0f, 0.0f, 30.0f, 45.0f, 0.40f}, {200.0f, 0.0f, 25.0f, 90.0f, 0.40f},
        {220.0f, 0.0f, 40.0f, 135.0f, 0.40f}, {80.0f, 0.0f, 275.0f, 180.0f, 0.40f},
        {120.0f, 0.0f, 285.0f, 225.0f, 0.40f}, {160.0f, 0.0f, 280.0f, 270.0f, 0.40f},
        {200.0f, 0.0f, 275.0f, 315.0f, 0.40f}, {220.0f, 0.0f, 290.0f, 0.0f, 0.40f},
        {90.0f, 0.0f, 90.0f, 45.0f, 0.40f}, {210.0f, 0.0f, 90.0f, 90.0f, 0.40f},
        {90.0f, 0.0f, 210.0f, 135.0f, 0.40f}, {210.0f, 0.0f, 210.0f, 180.0f, 0.40f},
        {75.0f, 0.0f, 130.0f, 225.0f, 0.40f}, {225.0f, 0.0f, 130.0f, 270.0f, 0.40f},
        {75.0f, 0.0f, 170.0f, 315.0f, 0.40f}, {225.0f, 0.0f, 170.0f, 0.0f, 0.40f},
        {110.0f, 0.0f, 60.0f, 45.0f, 0.40f}, {190.0f, 0.0f, 60.0f, 90.0f, 0.40f},
        {110.0f, 0.0f, 240.0f, 135.0f, 0.40f}, {190.0f, 0.0f, 240.0f, 180.0f, 0.40f},
        {140.0f, 0.0f, 100.0f, 225.0f, 0.40f}, {160.0f, 0.0f, 200.0f, 270.0f, 0.40f},
        {55.0f, 0.0f, 110.0f, 315.0f, 0.40f}, {245.0f, 0.0f, 110.0f, 0.0f, 0.40f},
        {55.0f, 0.0f, 190.0f, 45.0f, 0.40f}, {245.0f, 0.0f, 190.0f, 90.0f, 0.40f}
    };
    for (size_t i = 0; i < fixedTrees.size() && i < (size_t)count; ++i) { g_trees.push_back(fixedTrees[i]); }
}

void PlaceCoinsRandom(int count) {
    g_coins.clear();
    const float minDistFromObjects = 2.0f;
    const float minDistBetweenCoins = 3.0f;
    for (int i = 0; i < count; ++i) {
        const int maxTries = 200;
        float x = 0.0f, z = 0.0f;
        bool found = false;
        for (int t = 0; t < maxTries; ++t) {
            x = frand(2.0f, LAND_SIZE - 2.0f); z = frand(2.0f, LAND_SIZE - 2.0f);
            if (!IsOverLand(x, z)) continue;
            if (CollidesWithRock(x, z, minDistFromObjects) || CollidesWithTree(x, z, minDistFromObjects) || CollidesWithHouse(x, z, minDistFromObjects)) continue;
            auto OverlapsAnyCoin = [&](float cx, float cz, float minD) {
                for (const auto& c : g_coins) { float dx = cx - c.x, dz = cz - c.z; if ((dx * dx + dz * dz) < (minD * minD)) return true; } return false;
                };
            if (OverlapsAnyCoin(x, z, minDistBetweenCoins)) continue;
            float dx = x - playerX, dz = z - playerZ; if ((dx * dx + dz * dz) < (minDistFromObjects * minDistFromObjects)) continue;
            dx = x - keyObj.x, dz = z - keyObj.z; if ((dx * dx + dz * dz) < (minDistFromObjects * minDistFromObjects)) continue;
            found = true; break;
        }
        if (!found) { if (x < 2.0f) x = 2.0f; else if (x > (LAND_SIZE - 2.0f)) x = LAND_SIZE - 2.0f; if (z < 2.0f) z = 2.0f; else if (z > (LAND_SIZE - 2.0f)) z = LAND_SIZE - 2.0f; }
        g_coins.push_back(CoinInstance{ x, 1.0f, z, 0.0f, 0.01f, true });
    }
}

static void PlaceHousesStreet() {
    g_houses.clear();
    const float centerX = WORLD_SIZE * 0.5f; const float centerZ = WORLD_SIZE * 0.5f;
    const float roadWidth = 16.0f; const float houseOffsetX = 12.0f; const float houseSpacingZ = 6.0f;
    const float rowLeftX = centerX - (roadWidth * 0.5f) - houseOffsetX;
    const float rowRightX = centerX + (roadWidth * 0.5f) + houseOffsetX;
    const float startZ = centerZ - (houseSpacingZ * 2.0f);
    const float y = 0.2f;
    auto yawForIndex = [](int i) -> float { return 0.0f; };
    for (int i = 0; i < 5; ++i) {
        float z = startZ + i * houseSpacingZ; float yaw = yawForIndex(i);
        g_houses.push_back(HouseInstance{ rowLeftX, y, z, yaw, 0.01f });
        g_houses.push_back(HouseInstance{ rowRightX, y, z, yaw, 0.01f });
    }
}

void PlaceRocksRandom(int countPerModel) {
    g_rocks.clear();
    std::vector<RockInstance> fixedRocks = {
        {25.0f, 0.0f, 35.0f, 30.0f, 0.01f, 0}, {275.0f, 0.0f, 35.0f, 60.0f, 0.01f, 1},
        {25.0f, 0.0f, 265.0f, 90.0f, 0.01f, 2}, {275.0f, 0.0f, 265.0f, 120.0f, 0.01f, 3},
        {70.0f, 0.0f, 25.0f, 150.0f, 0.01f, 4}, {150.0f, 0.0f, 30.0f, 180.0f, 0.01f, 0},
        {230.0f, 0.0f, 25.0f, 210.0f, 0.01f, 1}, {70.0f, 0.0f, 275.0f, 240.0f, 0.01f, 2},
        {150.0f, 0.0f, 280.0f, 270.0f, 0.01f, 3}, {230.0f, 0.0f, 275.0f, 300.0f, 0.01f, 4},
        {25.0f, 0.0f, 100.0f, 330.0f, 0.01f, 0}, {30.0f, 0.0f, 180.0f, 0.0f, 0.01f, 1},
        {275.0f, 0.0f, 100.0f, 30.0f, 0.01f, 2}, {280.0f, 0.0f, 180.0f, 60.0f, 0.01f, 3},
        {85.0f, 0.0f, 80.0f, 90.0f, 0.01f, 4}, {215.0f, 0.0f, 80.0f, 120.0f, 0.01f, 0},
        {85.0f, 0.0f, 220.0f, 150.0f, 0.01f, 1}, {215.0f, 0.0f, 220.0f, 180.0f, 0.01f, 2},
        {100.0f, 0.0f, 120.0f, 210.0f, 0.01f, 3}, {200.0f, 0.0f, 120.0f, 240.0f, 0.01f, 4},
        {100.0f, 0.0f, 180.0f, 270.0f, 0.01f, 0}, {200.0f, 0.0f, 180.0f, 300.0f, 0.01f, 1},
        {50.0f, 0.0f, 140.0f, 330.0f, 0.01f, 2}, {250.0f, 0.0f, 140.0f, 0.0f, 0.01f, 3},
        {50.0f, 0.0f, 160.0f, 30.0f, 0.01f, 4}, {250.0f, 0.0f, 160.0f, 60.0f, 0.01f, 0},
        {120.0f, 0.0f, 55.0f, 90.0f, 0.01f, 1}, {180.0f, 0.0f, 55.0f, 120.0f, 0.01f, 2},
        {120.0f, 0.0f, 245.0f, 150.0f, 0.01f, 3}, {180.0f, 0.0f, 245.0f, 180.0f, 0.01f, 4}
    };
    for (const auto& rock : fixedRocks) { g_rocks.push_back(rock); }
}

// ---------------- LEVEL 2 PLACEMENT FUNCTION ----------------

void InitLevel2() {
    lvl2_platforms.clear();
    lvl2_pendulums.clear();

    // 1. STARTING PLATFORM (Center at 0, 0)
    lvl2_platforms.push_back({ 0.0f, 0.0f, 15.0f, 15.0f, 0.0f });

    // 2. THE SPIKE CORRIDOR (Straight path with swings)
    lvl2_platforms.push_back({ 0.0f, 40.0f, 8.0f, 60.0f, 0.0f });

    // Swings (Side-to-Side)
    lvl2_pendulums.push_back({ 0.0f, 15.0f, 20.0f, 12.0f, 0.0f, 60.0f, 3.0f, true });
    lvl2_pendulums.push_back({ 0.0f, 15.0f, 40.0f, 12.0f, 0.0f, 60.0f, 4.0f, true });
    lvl2_pendulums.push_back({ 0.0f, 15.0f, 60.0f, 12.0f, 0.0f, 60.0f, 2.5f, true });

    // 3. THE SPLIT (Safe platform)
    lvl2_platforms.push_back({ 0.0f, 80.0f, 20.0f, 15.0f, 0.0f });

    // 4. THE KEY PATH (Side Platform)
    lvl2_platforms.push_back({ 25.0f, 80.0f, 25.0f, 8.0f, 0.0f }); // Bridge to right
    lvl2_platforms.push_back({ 40.0f, 80.0f, 15.0f, 15.0f, 0.0f }); // Key Platform

    // Set Key Position
    lvl2_key.x = 40.0f; lvl2_key.y = 2.0f; lvl2_key.z = 80.0f;

    // 5. THE FINAL GAUNTLET (To Chest)
    lvl2_platforms.push_back({ 0.0f, 110.0f, 8.0f, 40.0f, 0.0f });

    // More Pendulums (Faster)
    lvl2_pendulums.push_back({ 0.0f, 15.0f, 100.0f, 12.0f, 0.0f, 70.0f, 5.0f, true });
    lvl2_pendulums.push_back({ 0.0f, 15.0f, 120.0f, 12.0f, 0.0f, 70.0f, 5.0f, true });

    // 6. CHEST PLATFORM
    lvl2_platforms.push_back({ 0.0f, 135.0f, 20.0f, 10.0f, 1.0f });
    lvl2_chest.x = 0.0f; lvl2_chest.y = 2.0f; lvl2_chest.z = 135.0f;
}

// ---------------- RENDERING PRIMITIVES ----------------

// Custom coin rendering function
void DrawCustomCoin() {
    glDisable(GL_TEXTURE_2D); glEnable(GL_LIGHTING);
    GLfloat coinAmbient[] = { 0.9f, 0.9f, 0.0f, 1.0f };
    GLfloat coinDiffuse[] = { 1.0f, 1.0f, 0.0f, 1.0f };
    GLfloat coinSpecular[] = { 1.0f, 1.0f, 0.5f, 1.0f };
    GLfloat coinShininess[] = { 50.0f };
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, coinAmbient);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, coinDiffuse);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, coinSpecular);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, coinShininess);
    const float radius = 0.5f; const float thickness = 0.15f; const int slices = 20;
    GLUquadricObj* quadric = gluNewQuadric();
    gluQuadricDrawStyle(quadric, GLU_FILL); gluQuadricNormals(quadric, GLU_SMOOTH);
    gluCylinder(quadric, radius, radius, thickness, slices, 1);
    glPushMatrix(); glTranslatef(0, 0, thickness); gluDisk(quadric, 0, radius, slices, 1); glPopMatrix();
    glPushMatrix(); glRotatef(180, 1, 0, 0); gluDisk(quadric, 0, radius, slices, 1); glPopMatrix();
    gluDeleteQuadric(quadric);
    glEnable(GL_TEXTURE_2D);
}

void RenderText(float x, float y, const char* string) {
    glDisable(GL_LIGHTING); glDisable(GL_TEXTURE_2D);
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity();
    int w = glutGet(GLUT_WINDOW_WIDTH); int h = glutGet(GLUT_WINDOW_HEIGHT);
    gluOrtho2D(0, w, 0, h);
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity();
    glColor3f(1.0f, 1.0f, 1.0f); glRasterPos2f(x, y);
    for (const char* c = string; *c != '\0'; c++) { glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c); }
    glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW);
    glEnable(GL_TEXTURE_2D); glEnable(GL_LIGHTING);
}

// Forward declarations to satisfy compiler order
void RenderMenu();
static void RenderSkybox(float size);
void DrawLevelObjects();
void DrawHUD();

// Minimal implementations to resolve undefined identifiers
void RenderMenu() {
    // No-op placeholder. Implement full menu rendering as needed.
}
static void RenderSkybox(float size) {
    // No-op placeholder. Implement skybox rendering as needed.
}
void DrawLevelObjects() {
    // Minimal: only render Level 2 since support functions exist
    if (gameState == LEVEL_2) {
        RenderLevel2();
    }
}
void DrawHUD() {
    // No-op placeholder. Implement HUD rendering as needed.
}

// ---------------- SCENE INITIALIZATION & ASSET LOADING ----------------

void myInit(void) {
    glClearColor(0.5f, 0.8f, 0.9f, 0.0f);
    glMatrixMode(GL_PROJECTION); glLoadIdentity();
    gluPerspective(45.0, (GLdouble)WIDTH / (GLdouble)HEIGHT, 0.1, 300);
    glMatrixMode(GL_MODELVIEW); glLoadIdentity();
    glEnable(GL_LIGHTING); glEnable(GL_LIGHT0); glEnable(GL_LIGHT1);
    GLfloat a[] = { 0.5f, 0.5f, 0.5f, 1.0f }; glLightfv(GL_LIGHT0, GL_AMBIENT, a);
    GLfloat d[] = { 0.8f, 0.8f, 0.8f, 1.0f }; glLightfv(GL_LIGHT0, GL_DIFFUSE, d);
    glEnable(GL_DEPTH_TEST); glEnable(GL_NORMALIZE); glEnable(GL_COLOR_MATERIAL); glShadeModel(GL_SMOOTH);
    setvbuf(stdout, NULL, _IONBF, 0);
}

void LoadAssets() {
    model_pirate.Load("models/pirate/Pirate.3ds");
    model_key.Load("models/key/Key9.3DS");
    model_map.Load("models/map/map1.3ds");
    model_rocks[0].Load("models/rocks/Rock0.3ds"); model_rocks[1].Load("models/rocks/Rock1.3ds");
    model_rocks[2].Load("models/rocks/Rock2.3ds"); model_rocks[3].Load("models/rocks/Rock3.3ds");
    model_rocks[4].Load("models/rocks/Rock4.3ds");
    model_boat.Load("models/Boat/pirateships.3ds");
    model_palet.Load("models/palet/palet.3ds");
    model_houses.Load("models/medieval-structures-wip/MedievalHouses.3ds");
    model_tree.Load("models/tree/Tree1.3ds");

    // --- LOAD SPIKE MODEL FOR LEVEL 2 ---
    model_spike.Load("models/spike/spike.3ds");

    // --- LOAD CHEST MODEL AND TEXTURE ---
    model_chest_3d.Load("models/chest/chest.3ds");
    tex_chest.Load("models/chest/13449_Treasure_Chest_v1_l1.bmp");

    skyboxTexture.Load("textures/blu-sky-3.bmp");
    groundTexture.Load("textures/Dirt1.bmp");
    tex_menu_bg.Load("textures/menu_bg.bmp");
    tex_play_btn.Load("textures/play_btn.bmp");

    srand((unsigned)time(nullptr));
    PlaceRocksRandom(6);
    PlaceHousesStreet();
    PlaceTreesRandom(50);
    PlaceCoinsRandom(20);
    PlacePirateMapInRoad();
    PlaceBoatAtEdge();
    InitLevel2(); // Initialize Level 2 for later use
}

// ---------------- LOGIC UPDATES ----------------

// Reset player state for Level 2 transition/death
void ResetPlayerLvl2() {
    playerX = 0.0f;
    playerZ = 0.0f;
    playerY = 0.0f;
    velX = 0; velZ = 0; velY = 0;
    jumpCount = 0; grounded = true;
}

void UpdateMovement(float dt) {
    if (isFadingOut) return;

    float desiredX = 0.0f, desiredZ = 0.0f;
    const float yawRad = playerYaw * PI / 180.0f;
    const float fx = sinf(yawRad); const float fz = cosf(yawRad);
    const float lx = -fz; const float lz = fx;

    if (keyW) { desiredX -= fx; desiredZ -= fz; }
    if (keyS) { desiredX += fx; desiredZ += fz; }
    if (keyA) { desiredX += lx; desiredZ += lz; }
    if (keyD) { desiredX -= lx; desiredZ -= lz; }

    float len = sqrt(desiredX * desiredX + desiredZ * desiredZ);
    if (len > 0.0001f) {
        desiredX /= len; desiredZ /= len;
        velX += desiredX * accel * dt; velZ += desiredZ * accel * dt;
    }
    else {
        float vlen = sqrt(velX * velX + velZ * velZ);
        if (vlen > 0.0001f) {
            float baseFriction = grounded ? frictionGround : frictionAir;
            float dec = baseFriction * dt;
            float dragFactor = grounded ? 0.5f : 1.0f;
            dec += vlen * dragFactor * dt;

            float newLen = vlen - dec; if (newLen < 0.0f) newLen = 0.0f;
            float scale = (vlen > 0.0f) ? (newLen / vlen) : 0.0f;
            velX *= scale; velZ *= scale;
        }
        else { velX = 0.0f; velZ = 0.0f; }
    }

    float vlen = sqrt(velX * velX + velZ * velZ);
    if (vlen > maxSpeed) { float scale = maxSpeed / vlen; velX *= scale; velZ *= scale; }

    // Collision checks
    bool hitObstacle = false;

    // Check X axis
    float testX = playerX + velX * dt;
    bool hitWallX = (gameState == LEVEL_1) && (testX < 0.0f || testX > LAND_SIZE);
    bool hitNPC_X = CollidesWithNPCSilent(testX, playerZ, 0.0f) || CollidesWithBoatSilent(testX, playerZ, 0.0f);
    if (CollidesWithAnyObject(testX, playerZ, 0.0f) || hitNPC_X || hitWallX) {
        velX = 0;
        if (hitWallX) {
            if (testX < 0.0f) playerX = 0.0f;
            if (testX > LAND_SIZE) playerX = LAND_SIZE;
        }
        else if (!hitNPC_X) {
            hitObstacle = true;
        }
    }
    else { playerX = testX; }

    // Check Z axis
    float testZ = playerZ + velZ * dt;
    bool hitWallZ = (gameState == LEVEL_1) && (testZ < 0.0f || testZ > LAND_SIZE);
    bool hitNPC_Z = CollidesWithNPCSilent(playerX, testZ, 0.0f) || CollidesWithBoatSilent(playerX, testZ, 0.0f);
    if (CollidesWithAnyObject(playerX, testZ, 0.0f) || hitNPC_Z || hitWallZ) {
        velZ = 0;
        if (hitWallZ) {
            if (testZ < 0.0f) playerZ = 0.0f;
            if (testZ > LAND_SIZE) playerZ = LAND_SIZE;
        }
        else if (!hitNPC_Z) {
            hitObstacle = true;
        }
    }
    else { playerZ = testZ; }


    if (hitObstacle) {
        int currentTime = glutGet(GLUT_ELAPSED_TIME);
        if (currentTime - lastCollisionTime > COLLISION_SOUND_COOLDOWN) { MciPlayOnce(ALIAS_COLLISION); lastCollisionTime = currentTime; }
    }

    // Vertical movement (Gravity & Jump)
    velY -= gravity * dt; if (velY < maxFallSpeed) velY = maxFallSpeed;

    if (spaceTrigger && jumpCount < 2) {
        velY = jumpImpulse; grounded = false; jumpCount++; spaceTrigger = false; MciPlayOnce(ALIAS_JUMP);
    }

    playerY += velY * dt;

    // Ground/Water/Platform Landing
    if (playerY < GROUND_Y) {
        if (IsOverLand(playerX, playerZ)) {
            playerY = GROUND_Y; velY = 0.0f; grounded = true; jumpCount = 0;
        }
        else {
            grounded = false; velY = (velY > -5.0f) ? velY : -5.0f;
            // Level 2 Death from falling in Abyss
            if (gameState == LEVEL_2 && playerY < -20.0f) { ResetPlayerLvl2(); MciPlayOnce(ALIAS_COLLISION); }
        }
    }

    // Level 1 Platforms Landing
    if (gameState == LEVEL_1) {
        for (int i = 0; i < PLATFORM_COUNT; ++i) {
            const Platform& p = g_platforms[i]; const float s = p.size; const float topY = p.y;
            if (playerX >= (p.x - s) && playerX <= (p.x + s) && playerZ >= (p.z - s) && playerZ <= (p.z + s)) {
                if (playerY >= topY - 0.5f && playerY <= topY + 1.0f && velY <= 0.0f) {
                    playerY = topY; velY = 0.0f; grounded = true; jumpCount = 0;
                }
            }
        }
    }

    // Level 2 Collision (Death Hazard)
    if (gameState == LEVEL_2 && CollidesWithPendulum(playerX, playerZ, playerY, 0.0f)) {
        ResetPlayerLvl2();
        MciPlayOnce(ALIAS_COLLISION);
    }
}

void CheckGameLogic() {
    float pickupDist = 2.0f;

    if (gameState == LEVEL_1) {
        // Coin/Key/Map Pickups (Level 1)
        for (auto& coin : g_coins) {
            if (coin.active) {
                float d = sqrt(pow(playerX - coin.x, 2) + pow(playerZ - coin.z, 2));
                if (d < pickupDist) { coin.active = false; score += 1; coinsCollected++; MciPlayOnce(ALIAS_COIN_PICKUP); }
            }
        }
        if (keyObj.active) {
            float d = sqrt(pow(playerX - keyObj.x, 2) + pow(playerZ - keyObj.z, 2));
            if (d < pickupDist) { keyObj.active = false; hasKey = true; score += 50; }
        }
        if (g_mapRoad.placed) {
            float d = sqrt(pow(playerX - g_mapRoad.x, 2) + pow(playerZ - g_mapRoad.z, 2));
            if (d < pickupDist) { g_mapRoad.placed = false; hasMap = true; score += 10; MciPlayOnce(ALIAS_MAP_PICKUP); }
        }

        // NPC Interaction Check
        showInteractPrompt = (g_npc.placed && sqrt(pow(playerX - g_npc.x, 2) + pow(playerZ - g_npc.z, 2)) < NPC_INTERACT_DISTANCE);

        // Boat Interaction Check
        showBoatPrompt = (g_boat.placed && sqrt(pow(playerX - g_boat.x, 2) + pow(playerZ - g_boat.z, 2)) < BOAT_INTERACT_DISTANCE);

        // Win condition (Level 1)
        int coinsRemaining = 0;
        for (const auto& coin : g_coins) { if (coin.active) coinsRemaining++; }
    }
    else if (gameState == LEVEL_2) {
        // Pick up Key (Level 2)
        if (lvl2_key.active) {
            float d = sqrt(pow(playerX - lvl2_key.x, 2) + pow(playerZ - lvl2_key.z, 2));

            // --- FIX: Reduced radius to 2.0f so it doesn't vanish before you reach it ---
            if (d < 2.0f) {
                lvl2_key.active = false;
                hasLvl2Key = true;
                MciPlayOnce(ALIAS_COIN_PICKUP);
            }
        }

        // Open Chest (Level 2 WIN)
        float d = sqrt(pow(playerX - lvl2_chest.x, 2) + pow(playerZ - lvl2_chest.z, 2));
        if (d < 3.0f && hasLvl2Key) {
            gameState = WIN;
            MciStop(ALIAS_BGM);
            if (!gameOverSoundPlayed) { MciPlayOnce(ALIAS_GAMEOVER); gameOverSoundPlayed = true; }
        }
    }
}


void myDisplay(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (gameState == MENU) {
        RenderMenu();
    }
    else if (gameState == LEVEL_1 || gameState == LEVEL_2) {
        // Camera Setup
        glLoadIdentity();
        float eyeX, eyeY, eyeZ, centerX, centerY, centerZ;
        float rad = camYaw * PI / 180.0f;
        if (isFirstPerson) {
            eyeX = playerX; eyeY = playerY + 1.4f; eyeZ = playerZ;
            centerX = playerX - 10 * sin(rad); centerY = playerY + 1.4f - 10 * sin(camPitch * PI / 180); centerZ = playerZ - 10 * cos(rad);
        }
        else {
            eyeX = playerX + camDistance * sin(rad); eyeY = playerY + 5.0f; eyeZ = playerZ + camDistance * cos(rad);
            centerX = playerX; centerY = playerY + 1.0f; centerZ = playerZ;
        }
        gluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, 0, 1, 0);

        // Skybox
        glPushMatrix(); glTranslatef(eyeX, eyeY, eyeZ); glDisable(GL_DEPTH_TEST); RenderSkybox(250.0f); glEnable(GL_DEPTH_TEST); glPopMatrix();

        // Lights
        GLfloat lightPos[] = { 0.0f, 20.0f, 0.0f, 1.0f }; glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
        GLfloat torchPos[] = { playerX, playerY + 1.5f, playerZ, 1.0f }; glLightfv(GL_LIGHT1, GL_POSITION, torchPos);

        // Scene Objects
        DrawLevelObjects();

        // Player
        if (!isFirstPerson) {
            glPushMatrix(); glTranslatef(playerX, playerY, playerZ); glRotatef(playerYaw + 180, 0, 1, 0); glScalef(0.02, 0.02, 0.02); model_pirate.Draw(); glPopMatrix();
        }

        // HUD
        DrawHUD();

        // FADE SCREEN
        if (fadeAlpha > 0.0f) {
            glDisable(GL_LIGHTING); glDisable(GL_TEXTURE_2D); glDisable(GL_DEPTH_TEST);
            glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity(); gluOrtho2D(0, WIDTH, 0, HEIGHT);
            glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity();
            glColor4f(0, 0, 0, fadeAlpha);
            glBegin(GL_QUADS); glVertex2f(0, 0); glVertex2f(WIDTH, 0); glVertex2f(WIDTH, HEIGHT); glVertex2f(0, HEIGHT); glEnd();
            glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW);
            glDisable(GL_BLEND); glEnable(GL_DEPTH_TEST); glEnable(GL_LIGHTING);
        }

    }
    else {
        // WIN/LOSE Screen
        glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity(); gluOrtho2D(0, WIDTH, 0, HEIGHT);
        glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity();
        glDisable(GL_LIGHTING); glDisable(GL_DEPTH_TEST); glColor3f(1, 1, 1);
        if (gameState == WIN) {
            RenderText(WIDTH / 2 - 100, HEIGHT / 2 + 30, "YOU WIN!");
            RenderText(WIDTH / 2 - 200, HEIGHT / 2, "You claimed the treasure!");
        }
        else {
            RenderText(WIDTH / 2 - 100, HEIGHT / 2 + 30, "GAME OVER!");
            RenderText(WIDTH / 2 - 150, HEIGHT / 2, "Time's up or mission failed!");
        }
        score = 1000 - gameTimer + (coinsCollected * 10);
        char finalScore[50]; sprintf(finalScore, "Final Score: %d", score); RenderText(WIDTH / 2 - 100, HEIGHT / 2 - 40, finalScore);
        RenderText(WIDTH / 2 - 120, HEIGHT / 2 - 80, "Press ESC to exit");
        glEnable(GL_DEPTH_TEST); glEnable(GL_LIGHTING);
        glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW);
    }
    glutSwapBuffers();
}


// ---------------- INPUT & ANIMATION ----------------

void myKeyboard(unsigned char button, int x, int y) {
    if (isFadingOut) return;
    switch (button) {
    case 'w': case 'W': keyW = true; break; case 's': case 'S': keyS = true; break;
    case 'a': case 'A': keyA = true; break; case 'd': case 'D': keyD = true; break;
    case ' ': spaceTrigger = true; break; case 'v': case 'V': isFirstPerson = !isFirstPerson; break;
    case 'e': case 'E':
        if (gameState == LEVEL_1) {
            if (showInteractPrompt) {
                MciPlayOnce(ALIAS_NPC_INTERACT); showNPCDialogue = true; dialogueTimer = 0.0f;
            }
            else if (showBoatPrompt) {
                MciPlayOnce(ALIAS_BOAT_INTERACT);
                if (coinsCollected >= BOAT_COST) {
                    if (hasMap) {
                        coinsCollected -= BOAT_COST; paidForBoat = true; isFadingOut = true;
                        showBoatDialogue = true; boatDialogueTimer = 0.0f; MciPlayOnce(ALIAS_COIN_PICKUP);
                    }
                    else {
                        showBoatDialogue2 = true; boatDialogueTimer = 0.0f;
                    }
                }
                else {
                    showBoatInsufficient = true; boatDialogueTimer = 0.0f;
                }
            }
        }
        break;
    case 27: Sound_Shutdown(); exit(0); break;
    }
}

void myKeyboardUp(unsigned char button, int x, int y) {
    switch (button) {
    case 'w': case 'W': keyW = false; break; case 's': case 'S': keyS = false; break;
    case 'a': case 'A': keyA = false; break; case 'd': case 'D': keyD = false; break;
    }
}
void myMouse(int button, int state, int x, int y) {
    if (gameState == MENU) {
        if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
            float btnW = 200, btnH = 100; float btnX = (WIDTH - btnW) / 2.0f; float btnY = 100.0f;
            int glY = HEIGHT - y;
            if (x >= btnX && x <= (btnX + btnW) && glY >= btnY && glY <= (btnY + btnH)) {
                gameState = LEVEL_1; // Start Level 1
                // Reset player to Level 1 start pos
                playerX = 2.0f; playerZ = 2.0f; playerY = 0.0f;
            }
            else {
                // If not clicking the button, and in menu, clicking should do nothing.
            }
        }
    }
    else { // When in LEVEL_1 or LEVEL_2
        if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
            // New logic: Toggle camera perspective on left click
            isFirstPerson = !isFirstPerson;
        }

        // Original right-click camera rotation logic
        if (button == GLUT_RIGHT_BUTTON) {
            rotatingCamera = (state == GLUT_DOWN);
            lastMouseX = x;
            lastMouseY = y;
        }
    }
}

void myMotion(int x, int y) {
    if (!rotatingCamera) return;
    camYaw += (x - lastMouseX) * 0.5f; camPitch -= (y - lastMouseY) * 0.5f;
    lastMouseX = x; lastMouseY = y;
    if (camPitch > 89) camPitch = 89; if (camPitch < -10) camPitch = -10;
    playerYaw = camYaw;
}

void myReshape(int w, int h) {
    if (h == 0) h = 1; glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION); glLoadIdentity();
    gluPerspective(45.0, (GLdouble)w / (GLdouble)h, 0.1, 300);
    glMatrixMode(GL_MODELVIEW);
}

void Anim() {
    static int lastT = -1; int t = glutGet(GLUT_ELAPSED_TIME);
    if (lastT == -1) lastT = t; float dt = (t - lastT) / 1000.0f; if (dt > 0.05f) dt = 0.05f; lastT = t;

    // Transition Logic
    if (isFadingOut) {
        fadeAlpha += dt * 0.8f;
        if (fadeAlpha >= 1.0f) {
            fadeAlpha = 1.0f; isFadingOut = false; gameState = LEVEL_2; isFadingIn = true;
            ResetPlayerLvl2();
        }
    }
    else if (isFadingIn) {
        fadeAlpha -= dt * 0.8f; if (fadeAlpha <= 0.0f) { fadeAlpha = 0.0f; isFadingIn = false; }
    }

    if (gameState == LEVEL_1 || gameState == LEVEL_2) {
        // --- FIX: Update Timer in BOTH levels so rotation works ---
        gameTimer += dt;

        if (gameState == LEVEL_1) {
            if (g_mapRoad.placed) { g_mapRoad.spinDeg += 60.0f * dt; if (g_mapRoad.spinDeg > 360.0f) g_mapRoad.spinDeg -= 360.0f; }
            for (auto& coin : g_coins) { coin.spinDeg += 120.0f * dt; if (coin.spinDeg > 360.0f) coin.spinDeg -= 360.0f; }
            // Dialogue Timers
            if (showNPCDialogue) { dialogueTimer += dt; if (dialogueTimer >= DIALOGUE_DURATION) showNPCDialogue = false; }
            if (showBoatDialogue || showBoatDialogue2 || showBoatInsufficient) { boatDialogueTimer += dt; if (boatDialogueTimer >= DIALOGUE_DURATION) { showBoatDialogue = false; showBoatDialogue2 = false; showBoatInsufficient = false; } }

        }
        else if (gameState == LEVEL_2) {
            // Update Pendulums
            for (auto& p : lvl2_pendulums) {
                p.currentAngle = p.maxAngle * sin(t / 1000.0f * p.speed);
            }
        }

        UpdateMovement(dt); CheckGameLogic();
    }
    glutPostRedisplay();
}

void main(int argc, char** argv) {
    glutInit(&argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(WIDTH, HEIGHT); glutInitWindowPosition(100, 150); glutCreateWindow(title);
    glutDisplayFunc(myDisplay); glutKeyboardFunc(myKeyboard); glutKeyboardUpFunc(myKeyboardUp);
    glutMouseFunc(myMouse); glutMotionFunc(myMotion); glutReshapeFunc(myReshape); glutIdleFunc(Anim);
    myInit(); LoadAssets(); Sound_Init();
    MciPlayLoop(ALIAS_BGM);
    glutMainLoop();
    Sound_Shutdown();
}